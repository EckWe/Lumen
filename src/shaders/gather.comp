#version 460
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require
#extension GL_KHR_shader_subgroup_arithmetic : enable
#include "commons.h"
#include "utils.glsl"
layout(local_size_x = 1024, local_size_y =1, local_size_z = 1) in;
layout(set = 1, binding = 1, scalar) buffer SceneDesc_ {
    SceneDesc scene_desc;
};
layout(buffer_reference, scalar) buffer SPPMData_ { SPPMData d[]; };
layout(buffer_reference, scalar) buffer AtomicData_ { AtomicData d; };
layout(buffer_reference, scalar) buffer HashData_ { HashData d[]; };
layout(buffer_reference, scalar) buffer PhotonData_ { PhotonHash d[]; };
SPPMData_ sppm_data = SPPMData_(scene_desc.sppm_data_addr);
AtomicData_ atomic_data = AtomicData_(scene_desc.atomic_data_addr);
PhotonData_ photons = PhotonData_(scene_desc.photon_addr);
HashData_ hash_data = HashData_(scene_desc.hash_addr);
// TODO: Send the dimension info later
uint size = 1600 * 900;

vec3 normalize_grid(vec3 p, vec3 min_bnds, vec3 max_bnds) {
    return (p - min_bnds) / (max_bnds - min_bnds);
}

ivec3 get_grid_idx(vec3 p, vec3 min_bnds, vec3 max_bnds, ivec3 grid_res) {
    ivec3 res = ivec3(normalize_grid(p, min_bnds, max_bnds) * grid_res);
    clamp(res, vec3(0), grid_res - vec3(1));
    return res;
}

void main() {
	uint idx = gl_GlobalInvocationID.x;
    if(idx >= size){
        return;
    }
    vec3 p =  sppm_data.d[idx].p;
    vec3 r = vec3(sppm_data.d[idx].radius);
    float r_sqr = dot(r,r);
    ivec3 grid_min_bnds_idx = get_grid_idx(p - r , atomic_data.d.min_bnds,
                              atomic_data.d.max_bnds, atomic_data.d.grid_res);
    ivec3 grid_max_bnds_idx = get_grid_idx(p + r, atomic_data.d.min_bnds,
                              atomic_data.d.max_bnds, atomic_data.d.grid_res);
    for(int x = grid_min_bnds_idx.x; x <= grid_max_bnds_idx.x; x++) {
        for(int y = grid_min_bnds_idx.y; y <= grid_max_bnds_idx.y; y++) {
            for(int z = grid_min_bnds_idx.z; z <= grid_max_bnds_idx.z; z++) {
                uint h = hash(ivec3(x,y,z), size);
                if(photons.d[h].photon_count > 0){
                    vec3 pp = p - photons.d[h].pos; 
                  
                    if(dot(pp, pp) > r_sqr) {
                        continue;
                    }
                    vec3 phi = photons.d[h].photon_count * photons.d[h].throughput * sppm_data.d[idx].bsdf;
                    sppm_data.d[idx].phi += phi;
                    sppm_data.d[idx].M += 1;
                }
            }
        }
    }
}