#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require

#include "../../commons.glsl"
layout(push_constant) uniform _PushConstantRay { PushConstantRay pc_ray; };
// VCM buffers
layout(buffer_reference, scalar) buffer PhotonData_ { PhotonHash d[]; };
layout(buffer_reference, scalar) buffer VCMVertex_ { VCMVertex d[]; };
layout(buffer_reference, scalar) buffer LightPathCnt { uint d[]; };
layout(buffer_reference, scalar) buffer ColorStorages { vec3 d[]; };

layout(buffer_reference, scalar) buffer VCMReservoir_ { VCMReservoir d[]; };

layout(buffer_reference, scalar) buffer SelectedReservoirs_ {
    SelectedReservoirs d[];
};

layout(buffer_reference, scalar) buffer LightSamples { VCMRestirData d[]; };
layout(buffer_reference, scalar) buffer ShouldResample { uint d; };
layout(buffer_reference, scalar) buffer LightStates { LightState d[]; };
layout(buffer_reference, scalar) buffer Angles { AngleStruct d[]; };

layout(constant_id = 0) const int RAY_GUIDE = 0;

PhotonData_ photons = PhotonData_(scene_desc.photon_addr);
VCMVertex_ vcm_lights = VCMVertex_(scene_desc.vcm_vertices_addr);
LightPathCnt light_path_cnts = LightPathCnt(scene_desc.path_cnt_addr);
ColorStorages tmp_col = ColorStorages(scene_desc.color_storage_addr);
LightSamples light_samples = LightSamples(scene_desc.light_samples_addr);
ShouldResample should_resample =
    ShouldResample(scene_desc.should_resample_addr);
LightStates light_states = LightStates(scene_desc.light_state_addr);
Angles angles = Angles(scene_desc.angle_struct_addr);

VCMReservoir_ temporal_reservoirs =
    VCMReservoir_(scene_desc.vcm_reservoir_addr);
SelectedReservoirs_ selected_reservoirs =
    SelectedReservoirs_(scene_desc.selected_reservoirs_addr);

uint screen_size = gl_LaunchSizeEXT.x * gl_LaunchSizeEXT.y;
const uint flags = gl_RayFlagsOpaqueEXT;
const float tmin = 0.001;
const float tmax = 10000.0;
#define RR_MIN_DEPTH 3
uint pixel_idx = (gl_LaunchIDEXT.x * gl_LaunchSizeEXT.y + gl_LaunchIDEXT.y);
uvec4 seed = init_rng(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy,
                      pc_ray.total_frame_num ^ pc_ray.random_num);
uint vcm_light_path_idx =
    (gl_LaunchIDEXT.x * gl_LaunchSizeEXT.y + gl_LaunchIDEXT.y) *
    (pc_ray.max_depth + 1);

const uint FRAME_INTERVAL = 10;

uint restir_hash(ivec3 p, uint size) {
    return uint((p.x * 73856093) ^ (p.y * 19349663) ^ p.z * 83492791) % size;
}

vec3 normalize_grid(vec3 p, vec3 min_bnds, vec3 max_bnds) {
    return (p - min_bnds) / (max_bnds - min_bnds);
}

ivec3 get_grid_idx(vec3 p, vec3 min_bnds, vec3 max_bnds, ivec3 grid_res) {
    ivec3 res = ivec3(normalize_grid(p, min_bnds, max_bnds) * grid_res);
    clamp(res, vec3(0), grid_res - vec3(1));
    return res;
}

vec3 vcm_connect_cam(const vec3 cam_pos, const vec3 cam_nrm, vec3 n_s,
                     const float cam_A, const vec3 pos, const in VCMState state,
                     const float eta_vm, const vec3 wo, const Material mat,
                     out ivec2 coords) {
    vec3 L = vec3(0);
    vec3 dir = cam_pos - pos;
    float len = length(dir);
    dir /= len;
    float cos_y = dot(dir, n_s);
    float cos_theta = dot(cam_nrm, -dir);
    if (cos_theta <= 0.) {
        return L;
    }

    // if(dot(n_s, dir) < 0) {
    //     n_s *= -1;
    // }
    // pdf_rev / pdf_fwd
    // in the case of light coming to camera
    // simplifies to abs(cos(theta)) / (A * cos^3(theta) * len^2)
    float cos_3_theta = cos_theta * cos_theta * cos_theta;
    const float cam_pdf_ratio = abs(cos_y) / (cam_A * cos_3_theta * len * len);
    vec3 ray_origin = offset_ray2(pos, n_s);
    float pdf_rev, pdf_fwd;
    const vec3 f = eval_bsdf(n_s, wo, mat, 0, dot(payload.n_s, wo) > 0, dir,
                             pdf_fwd, pdf_rev, cos_y);
    if (f == vec3(0)) {
        return L;
    }
    if (cam_pdf_ratio > 0.0) {
        any_hit_payload.hit = 1;
        traceRayEXT(tlas,
                    gl_RayFlagsTerminateOnFirstHitEXT |
                        gl_RayFlagsSkipClosestHitShaderEXT,
                    0xFF, 1, 0, 1, ray_origin, 0, dir, len - EPS, 1);
        if (any_hit_payload.hit == 0) {
            const float w_light = (cam_pdf_ratio / (screen_size)) *
                                  (eta_vm + state.d_vcm + pdf_rev *
                                  state.d_vc);
         
            const float mis_weight = 1. / (1. + w_light);
            // We / pdf_we * abs(cos_theta) = cam_pdf_ratio
            L = mis_weight * state.throughput * cam_pdf_ratio * f / screen_size;
            // if(isnan(luminance(L))) {
            //     debugPrintfEXT("%v3f\n", state.throughput);
            // }
        }
    }
    dir = -dir;
    vec4 target = ubo.view * vec4(dir.x, dir.y, dir.z, 0);
    target /= target.z;
    target = -ubo.projection * target;
    coords = ivec2(0.5 * (1 + target.xy) * gl_LaunchSizeEXT.xy - 0.5);
    if (coords.x < 0 || coords.x >= gl_LaunchSizeEXT.x || coords.y < 0 ||
        coords.y >= gl_LaunchSizeEXT.y || dot(dir, cam_nrm) < 0) {
        return vec3(0);
    }
    return L;
}

uint get_restir_hash_idx(uint light_idx, float u, float v) {
    const int base_res =
        int(sqrt(float(screen_size) / pc_ray.light_triangle_count));
    ivec3 grid_res = ivec3(pc_ray.light_triangle_count, base_res, base_res);
    ivec3 grid_idx =
        get_grid_idx(vec3(light_idx, u, v), vec3(0, 0, 0),
                     vec3(pc_ray.light_triangle_count, 1, 1), grid_res);

    return restir_hash(grid_idx, screen_size);
}

bool vcm_generate_light_sample(float eta_vc, out VCMState light_state,
                               out bool finite) {
    // Sample light
    uint light_idx;
    uint light_triangle_idx;
    uint light_material_idx;
    vec2 uv_unused;
    LightRecord light_record;
    vec3 wi, pos;
    float pdf_pos, pdf_dir, pdf_emit, pdf_direct;
    float cos_theta;
    const vec3 Le = sample_light_Le(
        seed, pc_ray.num_lights, pc_ray.light_triangle_count, cos_theta,
        light_record, pos, wi, pdf_pos, pdf_dir, pdf_emit, pdf_direct);
    if (pdf_dir <= 0) {
        return false;
    }
    light_state.pos = pos;
    light_state.area = 1.0 / pdf_pos;
    light_state.wi = wi;
    light_state.throughput = Le * cos_theta / (pdf_dir * pdf_pos);

    // Partially evaluate pdfs (area formulation)
    // At s = 0 this is p_rev / p_fwd, in the case of area lights:
    // p_rev = p_connect = 1/area, p_fwd = cos_theta / (PI * area)
    // Note that pdf_fwd is in area formulation, so cos_y / r^2 is missing
    // currently.
    light_state.d_vcm = pdf_direct / pdf_emit;
    // g_prev / p_fwd
    // Note that g_prev component in d_vc and d_vm lags by 1 iter
    // So we initialize g_prev to cos_theta of the current iter
    // Also note that 1/r^2 in the geometry term cancels for vc and vm
    // By convention pdf_fwd sample the i'th vertex from i-1
    // g_prev or pdf_prev samples from i'th vertex to i-1
    // In that sense, cos_theta terms will be common in g_prev and pdf_pwd
    // Similar argument, with the eta
    finite = is_light_finite(light_record.flags);
    if (!is_light_delta(light_record.flags)) {
        light_state.d_vc = (finite ? cos_theta : 1) / (pdf_dir * pdf_pos);
    } else {
        light_state.d_vc = 0;
    }
    light_state.d_vm = light_state.d_vc * eta_vc;
    return true;
}

void load_vcm_state(float eta_vc, const VCMReservoir r,
                    const LightState light_state, out VCMState state,
                    bool use_reservoir) {
    // float pdf_pos = light_state.triangle_pdf / pc_ray.light_triangle_count;
    // vec3 wi;
    // float W;
    // float cos_theta;
    // if (use_reservoir && r.W > 0) {
    //     wi = r.s.dir;
    //     cos_theta = abs(dot(wi, light_state.normal));

    //     // float cos_deg = degrees(acos(cos_theta));
    //     // if(true) {
    //     // //if(light_state.hash_idx == 1231707) {
    //     //     angles.d[pixel_idx % pc_ray.max_angle_samples].is_active = 1;
    //     //     angles.d[pixel_idx % pc_ray.max_angle_samples].theta =
    //     //     acos(cos_theta); angles.d[pixel_idx %
    //     //     pc_ray.max_angle_samples].phi = r.s.phi;
    //     // }
    //     W = r.W;
    // } else {
    //     wi = light_state.dir;
    //     const float pdf_dir =
    //         light_pdf_Le(light_state.light_flags, light_state.normal, wi);
    //     cos_theta = abs(dot(wi, light_state.normal));
    //     W = 1. / pdf_dir;
    // }
    // state.pos = light_state.pos;
    // state.n_s = light_state.normal;
    // state.area = 1.0 / light_state.triangle_pdf;
    // state.wi = wi;
    // state.throughput = light_state.Le * cos_theta * W / (pdf_pos);
    // state.d_vcm = W;
    // if (!is_light_delta(light_state.light_flags)) {
    //     const float cos_factor =
    //         is_light_finite(light_state.light_flags) ? cos_theta : 1;
    //     state.d_vc = cos_factor * W / (pdf_pos);
    // } else {
    //     state.d_vc = 0;
    // }
    // state.d_vm = state.d_vc * eta_vc;
}

void main() {
    const vec2 pixel = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 in_uv = pixel / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = in_uv * 2.0 - 1.0;
    vec4 origin = ubo.inv_view * vec4(0, 0, 0, 1);
    vec4 target = ubo.inv_projection * vec4(d.x, d.y, 1, 1);
    vec3 direction = vec3(sample_camera(d));
    vec4 area_int = (ubo.inv_projection * vec4(2. / gl_LaunchSizeEXT.x,
                                               2. / gl_LaunchSizeEXT.y, 0, 1));
    area_int /= (area_int.w);
    const float cam_area = abs(area_int.x * area_int.y);
    VCMState vcm_state;

#define light_vtx(i) vcm_lights.d[vcm_light_path_idx + i]
    const float radius = pc_ray.radius;
    const float radius_sqr = radius * radius;
    float eta_vcm = PI * radius_sqr * screen_size;
    float eta_vc = (pc_ray.use_vc == 1) ? 1.0 / eta_vcm : 0;
    float eta_vm = (pc_ray.use_vm == 1) ? PI * radius_sqr * screen_size : 0;
    bool specular = false;
    bool result;
    bool finite;
    if (RAY_GUIDE == 1) {
        const LightState light_state = light_states.d[pixel_idx];
        VCMReservoir r;
        bool use_reservoir = false;
        if (should_resample.d == 0) {
            use_reservoir =
                (pixel_idx ==
                 temporal_reservoirs.d[light_state.hash_idx].selected_idx);
        }
        if (use_reservoir) {
            r = temporal_reservoirs.d[light_state.hash_idx];
        }
        load_vcm_state(eta_vc, r, light_state, vcm_state, use_reservoir);
        vec3 initial = vcm_state.throughput;
        finite = is_light_finite(light_state.light_flags);
    } else {
        if (!vcm_generate_light_sample(eta_vc, vcm_state, finite)) {
            return;
        }
    }

    // Trace light
    {
        const vec3 cam_pos = origin.xyz;
        const vec3 cam_nrm = vec3(-ubo.inv_view * vec4(0, 0, 1, 0));
        int depth;
        int path_idx = 0;
        light_vtx(path_idx).path_len = 0;
        for (depth = 1;; depth++) {
            traceRayEXT(tlas, flags, 0xFF, 0, 0, 0, vcm_state.pos, tmin,
                        vcm_state.wi, tmax, 0);
            if (payload.material_idx == -1) {
                break;
            }
            vec3 wo = vcm_state.pos - payload.pos;

            vec3 n_s = payload.n_s;
            vec3 n_g = payload.n_g;
            bool side = true;
            if (dot(payload.n_g, wo) <= 0.)
                n_g = -n_g;
            if (dot(n_g, n_s) < 0) {
                n_s = -n_s;
                side = false;
            }
            float cos_wo = dot(wo, n_s);
            float dist = length(payload.pos - vcm_state.pos);
            float dist_sqr = dist * dist;
            wo /= dist;
            const Material mat =
                load_material(payload.material_idx, payload.uv);
            const bool mat_specular =
                (mat.bsdf_props & BSDF_SPECULAR) == BSDF_SPECULAR;
            // Complete the missing geometry terms
            float cos_theta_wo = abs(dot(wo, n_s));

            if (depth > 1 || finite) {
                vcm_state.d_vcm *= dist_sqr;
            }
            vcm_state.d_vcm /= cos_theta_wo;
            vcm_state.d_vc /= cos_theta_wo;
            vcm_state.d_vm /= cos_theta_wo;
            if ((!mat_specular && (pc_ray.use_vc == 1 || pc_ray.use_vm == 1))) {

                // Copy to light vertex buffer
                // light_vtx(path_idx).wi = vcm_state.wi;
                light_vtx(path_idx).wo = wo; //-vcm_state.wi;
                light_vtx(path_idx).n_s = n_s;
                light_vtx(path_idx).pos = payload.pos;
                light_vtx(path_idx).uv = payload.uv;
                light_vtx(path_idx).material_idx = payload.material_idx;
                light_vtx(path_idx).area = payload.area;
                light_vtx(path_idx).throughput = vcm_state.throughput;
                light_vtx(path_idx).d_vcm = vcm_state.d_vcm;
                light_vtx(path_idx).d_vc = vcm_state.d_vc;
                light_vtx(path_idx).d_vm = vcm_state.d_vm;
                light_vtx(path_idx).path_len = depth + 1;
                light_vtx(path_idx).side = uint(side);
                path_idx++;
            }
            if (depth >= pc_ray.max_depth) {
                break;
            }
            // Reverse pdf in solid angle form, since we have geometry term
            // at the outer paranthesis
            if (!mat_specular &&
                (pc_ray.use_vc == 1 && depth < pc_ray.max_depth)) {
                // Connect to camera
                ivec2 coords;
                vec3 splat_col = vcm_connect_cam(
                    cam_pos, cam_nrm, n_s, cam_area, payload.pos, vcm_state,
                    eta_vm, wo, mat, coords);
                if (luminance(splat_col) > 0) {
                    uint idx = coords.x * gl_LaunchSizeEXT.y + coords.y;

                    tmp_col.d[idx] += splat_col;
                }
            }

            // Continue the walk
            float pdf_dir;
            float cos_theta;
            const vec3 f = sample_bsdf(n_s, wo, mat, 0, side, vcm_state.wi,
                                       pdf_dir, cos_theta, seed);
            const bool same_hemisphere = same_hemisphere(vcm_state.wi, wo, n_s);

            const bool mat_transmissive =
                (mat.bsdf_props & BSDF_TRANSMISSIVE) == BSDF_TRANSMISSIVE;
            if (f == vec3(0) || pdf_dir == 0 ||
                (!same_hemisphere && !mat_transmissive)) {
                break;
            }
            float pdf_rev = pdf_dir;
            if (!mat_specular) {
                pdf_rev = bsdf_pdf(mat, n_s, vcm_state.wi, wo);
            }
            const float abs_cos_theta = abs(cos_theta);

            vcm_state.pos = offset_ray(payload.pos, n_g);
            // Note, same cancellations also occur here from now on
            // see _vcm_generate_light_sample_
            if (!mat_specular) {
                vcm_state.d_vc =
                    (abs_cos_theta / pdf_dir) *
                    (eta_vm + vcm_state.d_vcm + pdf_rev * vcm_state.d_vc);
                vcm_state.d_vm =
                    (abs_cos_theta / pdf_dir) *
                    (1 + vcm_state.d_vcm * eta_vc + pdf_rev * vcm_state.d_vm);
                vcm_state.d_vcm = 1.0 / pdf_dir;
            } else {
                // Specular pdf has value = inf, so d_vcm = 0;
                vcm_state.d_vcm = 0;
                // pdf_fwd = pdf_rev = delta -> cancels
                vcm_state.d_vc *= abs_cos_theta;
                vcm_state.d_vm *= abs_cos_theta;
                specular = true;
            }
            vcm_state.throughput *= f * abs_cos_theta / pdf_dir;
            vcm_state.n_s = n_s;
            vcm_state.area = payload.area;
            vcm_state.material_idx = payload.material_idx;
        }
        light_path_cnts.d[pixel_idx] = path_idx;
        // "Build" the hash grid
        // TODO: Add sorting later
        if (pc_ray.use_vm == 1) {
            for (int i = 0; i < path_idx; i++) {
                ivec3 grid_idx =
                    get_grid_idx(light_vtx(i).pos, pc_ray.min_bounds,
                                 pc_ray.max_bounds, pc_ray.grid_res);
                uint h = hash(grid_idx, screen_size);
                photons.d[h].pos = light_vtx(i).pos;
                photons.d[h].wi = -light_vtx(i).wi;
                photons.d[h].d_vm = light_vtx(i).d_vm;
                photons.d[h].d_vcm = light_vtx(i).d_vcm;
                photons.d[h].throughput = light_vtx(i).throughput;
                photons.d[h].nrm = light_vtx(i).n_s;
                photons.d[h].path_len = light_vtx(i).path_len;
                atomicAdd(photons.d[h].photon_count, 1);
            }
        }
    }
#undef light_vtx
}