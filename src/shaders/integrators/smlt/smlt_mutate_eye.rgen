#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require
// Includes all the buffer addresses and indices
#include "smlt_commons.glsl"

void main() {
#define mlt_sampler mlt_samplers.d[mlt_sampler_idx]
#define splat(i) splat_data.d[splat_idx + i]
#define past_splat(i) past_splat_data.d[splat_idx + i]
    vec4 origin = ubo.inv_view * vec4(0, 0, 0, 1);
    vec4 area_int = (ubo.inv_projection * vec4(2. / gl_LaunchSizeEXT.x,
                                               2. / gl_LaunchSizeEXT.y, 0, 1));
    area_int /= area_int.w;
    const float cam_area = abs(area_int.x * area_int.y);

    uvec4 chain_seed = seeds_data.d[pixel_idx].chain_seed;
    const bool large_step = prob_carryover_data.d[pixel_idx] == 1;
    uvec4 seed = tmp_seeds_data.d[pixel_idx].chain_seed;
    
    mlt_start_chain(1);
    float proposed_luminance = mlt_trace_eye(origin, cam_area, large_step, chain_seed, true);

    if (isnan(proposed_luminance) || isinf(proposed_luminance)) {
        debugPrintfEXT("Luminance is not a finite number\n");
    }
    const float accept = min(1, proposed_luminance / mlt_sampler.luminance);
    if (accept > 0) {
        const float inv_proposed_luminance = 1. / proposed_luminance;
        for (int i = 0; i < mlt_sampler.splat_cnt; i++) {
            // if (proposed_luminance > 0) {
            //     ivec2 coords = ivec2(splat(i).idx / pc_ray.size_y,
            //                          splat(i).idx % pc_ray.size_y);
            //     debugPrintfEXT("%v2i - %d\n", coords,
            //     pc_ray.mutation_counter);
            //     //debugPrintfEXT("%d - %v3f\n", splat(i).idx,
            //     splat(i).L);
            // }
            mlt_col.d[splat(i).idx] +=
                splat(i).L * accept * inv_proposed_luminance;
        }
    }
    const float inv_past_luminance = 1. / mlt_sampler.luminance;
    for (int i = 0; i < mlt_sampler.past_splat_cnt; i++) {
           
        mlt_col.d[past_splat(i).idx] +=
            past_splat(i).L * (1 - accept) * inv_past_luminance;
    }
    if (rand(seed) < accept) {
        mlt_sampler.past_splat_cnt = mlt_sampler.splat_cnt;
        mlt_sampler.luminance = proposed_luminance;
        for (int i = 0; i < mlt_sampler.splat_cnt; i++) {
            past_splat(i).idx = splat(i).idx;
            past_splat(i).L = splat(i).L;
        }
        mlt_accept(large_step);
    } else {
        mlt_reject();
    }
    seeds_data.d[pixel_idx].chain_seed = chain_seed;
}